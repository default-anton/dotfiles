#!/usr/bin/env bash

# E2E tests: bin/e2e/stt.sh (fixtures in bin/e2e/fixtures/).
# If stt behavior changes (flags, output, errors, stdin/file handling,
# long media handling, or chunking), update tests + fixtures in the same change.
set -eo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/mlx-audio/constants.sh"
source "${SCRIPT_DIR}/mlx-audio/lib.sh"

MODEL="${DEFAULT_STT_MODEL}"
LANGUAGE=""
OUTPUT=""
INPUT_FILE=""
CHUNK_SECONDS="${STT_CHUNK_SECONDS:-}"
TARGET_BITRATE="${STT_TARGET_BITRATE:-48k}"

WORK_DIR="$(mktemp -d /tmp/stt_XXXXXX)"
trap 'rm -rf "${WORK_DIR}"' EXIT

fail() {
    echo "Error: $*" >&2
    exit 1
}

usage() {
    local exit_code="${1:-1}"
    cat <<EOF
Usage: $0 [INPUT_FILE_OR_URL] [--model MODEL] [--language LANG] [--output FILE] [--chunk-seconds N]

Transcribe audio/video to text using mlx-audio server.

Arguments:
  INPUT_FILE_OR_URL  Media file path or URL to transcribe (optional, reads from stdin if not provided)
  --model MODEL      STT model (default: ${DEFAULT_STT_MODEL})
  --language LANG    Language hint, e.g., 'en', 'es' (optional)
  --output FILE      Write transcription to file instead of stdout
  --chunk-seconds N  Chunk length in seconds (default: auto based on available memory)
  -h, --help         Show this help

Input can be local media, a supported URL (downloaded via yt-dlp), or stdin.
Input is normalized to mono MP3 (${TARGET_BITRATE}) before transcription.
Long inputs are split into chunks and combined.

Examples:
  $0 recording.mp3
  $0 "https://x.com/i/status/1234567890" --language en
  $0 "https://www.youtube.com/watch?v=dQw4w9WgXcQ" --language en
  $0 meeting.m4a --language en --output notes.txt
  $0 keynote.mp4 --language en --chunk-seconds 180
  tts "Ship boring software fast." --speed 1.2 --output /tmp/demo.mp3 && $0 /tmp/demo.mp3 --language en
  ffmpeg -i video.mp4 -f wav - | $0 --language en
EOF
    exit "${exit_code}"
}

require_command() {
    command -v "$1" >/dev/null 2>&1 || fail "Required command '$1' is not installed."
}

is_url() {
    [[ "$1" =~ ^https?:// ]]
}

download_url_audio() {
    local media_url="$1"
    local output_template="${WORK_DIR}/downloaded.%(ext)s"

    require_command yt-dlp
    echo "Info: Downloading media URL via yt-dlp..." >&2

    yt-dlp --no-playlist -x --audio-format mp3 -o "${output_template}" "${media_url}" >&2 || \
        fail "Failed to download media URL with yt-dlp."

    if [[ -s "${WORK_DIR}/downloaded.mp3" ]]; then
        printf '%s' "${WORK_DIR}/downloaded.mp3"
        return
    fi

    shopt -s nullglob
    local downloaded_files=("${WORK_DIR}"/downloaded.*)
    shopt -u nullglob

    local file
    for file in "${downloaded_files[@]}"; do
        [[ -s "${file}" ]] || continue
        printf '%s' "${file}"
        return
    done

    fail "yt-dlp finished but no audio file was produced."
}

get_available_memory_mb() {
    if [[ -n "${STT_AVAILABLE_MEMORY_MB:-}" ]]; then
        echo "${STT_AVAILABLE_MEMORY_MB}"
        return
    fi

    if command -v vm_stat >/dev/null 2>&1; then
        local vm_output page_size available_pages
        vm_output="$(vm_stat 2>/dev/null || true)"
        page_size="$(printf '%s\n' "${vm_output}" | awk -F'page size of | bytes' '/page size of/{print $2; exit}')"
        available_pages="$(printf '%s\n' "${vm_output}" | awk -F': *' '
            /Pages free|Pages speculative/ {gsub("\\.", "", $2); sum += $2}
            END {print int(sum)}
        ')"

        if [[ "${page_size}" =~ ^[0-9]+$ ]] && [[ "${available_pages}" =~ ^[0-9]+$ ]] && [[ "${available_pages}" -gt 0 ]]; then
            echo $((available_pages * page_size / 1024 / 1024))
            return
        fi
    fi

    local total_mem_bytes
    total_mem_bytes="$(sysctl -n hw.memsize 2>/dev/null || true)"
    if [[ "${total_mem_bytes}" =~ ^[0-9]+$ ]] && [[ "${total_mem_bytes}" -gt 0 ]]; then
        # Conservative fallback: use half of total memory as effective available budget.
        echo $((total_mem_bytes / 1024 / 1024 / 2))
        return
    fi

    echo 4096
}

select_chunk_seconds() {
    if [[ -n "${CHUNK_SECONDS}" ]]; then
        [[ "${CHUNK_SECONDS}" =~ ^[0-9]+$ ]] || fail "--chunk-seconds must be a positive integer."
        [[ "${CHUNK_SECONDS}" -gt 0 ]] || fail "--chunk-seconds must be greater than 0."
        echo "${CHUNK_SECONDS}"
        return
    fi

    local available_mb
    available_mb="$(get_available_memory_mb)"

    # Empirically tuned for mlx-community/parakeet-tdt-0.6b-v2 on local Macs.
    # Apple Silicon uses unified memory, so RAM budget is also VRAM budget.
    if ((available_mb < 4096)); then
        echo 60
    elif ((available_mb < 8192)); then
        echo 90
    elif ((available_mb < 16384)); then
        echo 120
    elif ((available_mb < 32768)); then
        echo 180
    else
        echo 300
    fi
}

media_duration_seconds() {
    local media_file="$1"
    local duration

    duration="$(ffprobe -v error -show_entries format=duration -of default=nw=1:nk=1 "${media_file}" 2>/dev/null || true)"
    if [[ "${duration}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        awk -v d="${duration}" 'BEGIN { printf "%.0f", d }'
        return
    fi

    echo 0
}

normalize_media_to_mp3() {
    local input_media="$1"
    local output_mp3="$2"

    ffmpeg -y -loglevel error \
        -i "${input_media}" \
        -vn \
        -ac 1 \
        -ar 16000 \
        -b:a "${TARGET_BITRATE}" \
        "${output_mp3}" || fail "Failed to decode input media with ffmpeg."
}

transcribe_file() {
    local audio_file="$1"
    local transcript

    local curl_args=(
        -s -f
        -X POST "http://localhost:${MLX_AUDIO_PORT}/v1/audio/transcriptions"
        -F "file=@${audio_file}"
        -F "model=${MODEL}"
    )

    [[ -n "${LANGUAGE}" ]] && curl_args+=(-F "language=${LANGUAGE}")

    if ! transcript="$(curl "${curl_args[@]}" | jq -r 'select(.text) | .text' | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^[[:space:]]+//; s/[[:space:]]+$//')"; then
        return 1
    fi

    if [[ -z "${transcript}" ]]; then
        return 1
    fi

    printf '%s' "${transcript}"
}

transcribe_media() {
    local prepared_audio="$1"
    local duration chunk_seconds available_mb

    duration="$(media_duration_seconds "${prepared_audio}")"
    chunk_seconds="$(select_chunk_seconds)"
    available_mb="$(get_available_memory_mb)"

    if ((duration <= chunk_seconds)); then
        transcribe_file "${prepared_audio}" || fail "Failed to transcribe audio."
        return
    fi

    local chunk_dir
    chunk_dir="${WORK_DIR}/chunks"
    mkdir -p "${chunk_dir}"

    echo "Info: Chunking audio into ${chunk_seconds}s segments (duration=${duration}s, available_mem=${available_mb}MB)." >&2

    ffmpeg -y -loglevel error \
        -i "${prepared_audio}" \
        -f segment \
        -segment_time "${chunk_seconds}" \
        -reset_timestamps 1 \
        -c:a copy \
        "${chunk_dir}/chunk_%04d.mp3" || fail "Failed to split long audio into chunks."

    shopt -s nullglob
    local chunks=("${chunk_dir}"/chunk_*.mp3)
    shopt -u nullglob

    ((${#chunks[@]} > 0)) || fail "No audio chunks were produced."

    local chunk transcript combined=""
    for chunk in "${chunks[@]}"; do
        transcript="$(transcribe_file "${chunk}")" || fail "Failed to transcribe chunk: ${chunk}"
        [[ -n "${transcript}" ]] && combined+="${combined:+ }${transcript}"
    done

    combined="$(printf '%s' "${combined}" | sed -E 's/[[:space:]]+/ /g; s/^[[:space:]]+//; s/[[:space:]]+$//')"
    [[ -n "${combined}" ]] || fail "Failed to transcribe audio chunks."

    printf '%s' "${combined}"
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --model)
            [[ $# -ge 2 ]] || fail "--model requires a value."
            MODEL="$2"
            shift 2
            ;;
        --language)
            [[ $# -ge 2 ]] || fail "--language requires a value."
            LANGUAGE="$2"
            shift 2
            ;;
        --output)
            [[ $# -ge 2 ]] || fail "--output requires a value."
            OUTPUT="$2"
            shift 2
            ;;
        --chunk-seconds)
            [[ $# -ge 2 ]] || fail "--chunk-seconds requires a value."
            CHUNK_SECONDS="$2"
            shift 2
            ;;
        -h|--help)
            usage 0
            ;;
        -* )
            echo "Unknown option: $1" >&2
            usage 1
            ;;
        *)
            if [[ -z "${INPUT_FILE}" ]]; then
                INPUT_FILE="$1"
                shift
            else
                echo "Unknown argument: $1" >&2
                usage 1
            fi
            ;;
    esac
done

require_command ffmpeg
require_command ffprobe
require_command curl
require_command jq

mlx_audio_server_ensure 2>/dev/null || exit 1

RAW_INPUT="${WORK_DIR}/input.media"
PREPARED_AUDIO="${WORK_DIR}/prepared.mp3"
SOURCE_MEDIA="${RAW_INPUT}"

if [[ -n "${INPUT_FILE}" ]]; then
    if is_url "${INPUT_FILE}"; then
        SOURCE_MEDIA="$(download_url_audio "${INPUT_FILE}")"
    else
        [[ -f "${INPUT_FILE}" ]] || fail "Audio file '${INPUT_FILE}' not found."
        cp "${INPUT_FILE}" "${SOURCE_MEDIA}"
    fi
else
    cat > "${SOURCE_MEDIA}"
fi

[[ -s "${SOURCE_MEDIA}" ]] || fail "No input media provided."

normalize_media_to_mp3 "${SOURCE_MEDIA}" "${PREPARED_AUDIO}"
TRANSCRIPT="$(transcribe_media "${PREPARED_AUDIO}")"

if [[ -n "${OUTPUT}" ]]; then
    printf '%s\n' "${TRANSCRIPT}" > "${OUTPUT}"
else
    printf '%s\n' "${TRANSCRIPT}"
fi
