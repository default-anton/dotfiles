#!/usr/bin/env bash
set -euo pipefail

required_env=(
  SUBWF_STEP_ID
  SUBWF_RUN_ID
  SUBWF_ACCESS_MODE
  SUBWF_CAPTURE_MODE
  SUBWF_PROMPT_FILE
  SUBWF_OUTPUT_FILE
  SUBWF_STATUS_FILE
  SUBWF_EXTENSION_FILE
  SUBWF_PI_BIN
  SUBWF_INPUTS_FILE
)

for name in "${required_env[@]}"; do
  [[ -n "${!name:-}" ]] || {
    echo "subwf-step-runner: missing env ${name}" >&2
    exit 2
  }
done

json_escape() {
  local value="${1:-}"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/\\r}"
  value="${value//$'\t'/\\t}"
  printf '%s' "$value"
}

write_atomic() {
  local path="$1"
  local content="$2"
  mkdir -p "$(dirname "$path")"
  local tmp="${path}.tmp.$$"
  printf '%s' "$content" > "$tmp"
  mv "$tmp" "$path"
}

write_status_json() {
  local status="$1"
  local stop_reason="$2"
  local error_message="$3"

  local payload
  payload=$(printf '{\n  "status": "%s",\n  "stepId": "%s",\n  "runId": "%s",\n  "stopReason": "%s",\n  "errorMessage": %s,\n  "outputFile": "%s",\n  "finishedAt": "%s"\n}\n' \
    "$(json_escape "$status")" \
    "$(json_escape "$SUBWF_STEP_ID")" \
    "$(json_escape "$SUBWF_RUN_ID")" \
    "$(json_escape "$stop_reason")" \
    "$(if [[ -n "$error_message" ]]; then printf '"%s"' "$(json_escape "$error_message")"; else printf 'null'; fi)" \
    "$(json_escape "$SUBWF_OUTPUT_FILE")" \
    "$(date -u +"%Y-%m-%dT%H:%M:%SZ")")

  write_atomic "$SUBWF_STATUS_FILE" "$payload"
}

write_failure_artifact() {
  local status="$1"
  local stop_reason="$2"
  local error_message="$3"

  local body="# Subagent step failed (${status})\n\n- step: ${SUBWF_STEP_ID}\n- stopReason: ${stop_reason}"
  if [[ -n "$error_message" ]]; then
    body+="\n- error: ${error_message}"
  fi
  body+="\n"

  write_atomic "$SUBWF_OUTPUT_FILE" "$body"
}

PROMPT_TEXT="$(cat "$SUBWF_PROMPT_FILE")"
INPUT_ARGS=()
while IFS= read -r input_path; do
  [[ -n "$input_path" ]] || continue
  INPUT_ARGS+=("@${input_path}")
done < "$SUBWF_INPUTS_FILE"

PI_ARGS=()
if [[ "$SUBWF_ACCESS_MODE" == "ro" ]]; then
  PI_ARGS+=(--no-session --tools "read,bash")
fi

EXIT_CODE=0
set +e
if [[ "$SUBWF_CAPTURE_MODE" == "print" ]]; then
  "$SUBWF_PI_BIN" "${PI_ARGS[@]}" -p "${INPUT_ARGS[@]}" "$PROMPT_TEXT" > "$SUBWF_OUTPUT_FILE"
  EXIT_CODE=$?
else
  SUBAGENT_OUTPUT_FILE="$SUBWF_OUTPUT_FILE" \
  SUBAGENT_STATUS_FILE="$SUBWF_STATUS_FILE" \
  SUBAGENT_STEP_ID="$SUBWF_STEP_ID" \
  SUBAGENT_RUN_ID="$SUBWF_RUN_ID" \
  "$SUBWF_PI_BIN" "${PI_ARGS[@]}" -e "$SUBWF_EXTENSION_FILE" "${INPUT_ARGS[@]}" "$PROMPT_TEXT"
  EXIT_CODE=$?
fi
set -e

if [[ "$SUBWF_CAPTURE_MODE" == "print" ]]; then
  if [[ "$EXIT_CODE" -eq 0 ]]; then
    if [[ -s "$SUBWF_OUTPUT_FILE" ]]; then
      write_status_json "success" "stop" ""
    else
      write_failure_artifact "no_output" "stop" "No assistant output captured in print fallback mode."
      write_status_json "no_output" "stop" "No assistant output captured in print fallback mode."
    fi
  else
    if [[ ! -f "$SUBWF_OUTPUT_FILE" ]]; then
      write_failure_artifact "error" "error" "pi exited with code ${EXIT_CODE} in print fallback mode."
    fi
    write_status_json "error" "error" "pi exited with code ${EXIT_CODE} in print fallback mode."
  fi
else
  if [[ ! -f "$SUBWF_STATUS_FILE" ]]; then
    if [[ ! -f "$SUBWF_OUTPUT_FILE" ]]; then
      write_failure_artifact "process_error" "error" "pi exited with code ${EXIT_CODE} before status capture."
    fi
    write_status_json "process_error" "error" "pi exited with code ${EXIT_CODE} before status capture."
  fi
fi
