#!/usr/bin/env bash
set -euo pipefail

CACHE_ROOT="${GH_SCOUT_CACHE_ROOT:-/tmp/gh_scout}"
MAX_LIST="${GH_SCOUT_MAX_LIST:-200}"
MAX_SEARCH="${GH_SCOUT_MAX_SEARCH:-50}"

usage() {
	cat <<'EOF'
Usage: gh_scout <command> [args]

Commands:
  repo-info OWNER/REPO
  ls OWNER/REPO [ref] [path]
  cat OWNER/REPO [ref] path
  cache OWNER/REPO [ref] path
  range OWNER/REPO [ref] path start end
  find-file OWNER/REPO pattern
  search OWNER/REPO query

Env:
  GH_SCOUT_CACHE_ROOT (default: /tmp/gh_scout)
  GH_SCOUT_MAX_LIST (default: 200)
  GH_SCOUT_MAX_SEARCH (default: 50)
EOF
}

die() {
	echo "gh_scout: $*" >&2
	exit 1
}

require_jq() {
	command -v jq >/dev/null 2>&1 || die "jq required"
}

split_repo() {
	local repo="$1"
	[[ "$repo" == */* ]] || die "repo must be owner/repo"
	OWNER="${repo%%/*}"
	REPO="${repo#*/}"
}

urlencode() {
	printf '%s' "$1" | jq -sRr @uri
}

urlencode_path() {
	local encoded
	encoded=$(printf '%s' "$1" | jq -sRr @uri)
	printf '%s' "${encoded//%2F/\/}"
}

api_get() {
	local url="$1"
	curl -fsSL -H "Accept: application/vnd.github+json" "$url"
}

api_get_textmatch() {
	local url="$1"
	curl -fsSL -H "Accept: application/vnd.github.text-match+json" "$url"
}

resolve_ref() {
	local repo="$1"
	local ref="${2:-}"
	if [[ -n "$ref" ]]; then
		printf '%s' "$ref"
		return
	fi
	split_repo "$repo"
	api_get "https://api.github.com/repos/$OWNER/$REPO" | jq -r '.default_branch'
}

cache_path() {
	local repo="$1"
	local ref="$2"
	local path="$3"
	split_repo "$repo"
	local safe_ref="${ref//\//__}"
	local clean_path="${path#/}"
	[[ -n "$clean_path" ]] || die "path required"
	[[ "$clean_path" != *".."* ]] || die "path traversal not allowed"
	printf '%s/%s/%s/%s/%s' "$CACHE_ROOT" "$OWNER" "$REPO" "$safe_ref" "$clean_path"
}

cache_listing_path() {
	local repo="$1"
	local ref="$2"
	local path="${3:-}"
	split_repo "$repo"
	local safe_ref="${ref//\//__}"
	local clean_path="${path#/}"
	if [[ "$clean_path" == "." ]]; then
		clean_path=""
	fi
	[[ "$clean_path" != *".."* ]] || die "path traversal not allowed"
	local base="$CACHE_ROOT/$OWNER/$REPO/$safe_ref/.listings"
	if [[ -n "$clean_path" ]]; then
		printf '%s/%s.listing' "$base" "$clean_path"
	else
		printf '%s/__root__.listing' "$base"
	fi
}

repo_info() {
	require_jq
	split_repo "$1"
	api_get "https://api.github.com/repos/$OWNER/$REPO" | jq -c '{full_name, default_branch, html_url, description}'
}

ls_dir() {
	require_jq
	local repo="$1"
	local ref="${2:-}"
	local path="${3:-}"
	local resolved
	resolved=$(resolve_ref "$repo" "$ref")
	split_repo "$repo"
	local clean_path="${path#/}"
	if [[ "$clean_path" == "." ]]; then
		clean_path=""
	fi
	local encoded_path=""
	if [[ -n "$clean_path" ]]; then
		encoded_path="/$(urlencode_path "$clean_path")"
	else
		encoded_path="/"
	fi
	local url="https://api.github.com/repos/$OWNER/$REPO/contents${encoded_path}?ref=$(urlencode "$resolved")"
	local listing
	listing=$(api_get "$url" | jq -r 'if type == "array" then .[] | "\(.type)\t\(.path)" else "\(.type)\t\(.path)" end' | head -n "$MAX_LIST")
	local listing_path
	listing_path=$(cache_listing_path "$repo" "$resolved" "$clean_path")
	mkdir -p "$(dirname "$listing_path")"
	printf '%s\n' "$listing" > "$listing_path"
	printf 'cached: %s\n' "$listing_path"
	if [[ -n "$listing" ]]; then
		printf '%s\n' "$listing"
	fi
}

cat_file() {
	require_jq
	local repo="$1"
	local ref="${2:-}"
	local path="$3"
	[[ -n "$path" ]] || die "path required"
	local resolved
	resolved=$(resolve_ref "$repo" "$ref")
	split_repo "$repo"
	local clean_path="${path#/}"
	local encoded_path
	encoded_path=$(urlencode_path "$clean_path")
	curl -fsSL "https://raw.githubusercontent.com/$OWNER/$REPO/$resolved/$encoded_path"
}

cache_file() {
	require_jq
	local repo="$1"
	local ref="${2:-}"
	local path="$3"
	[[ -n "$path" ]] || die "path required"
	local resolved
	resolved=$(resolve_ref "$repo" "$ref")
	local dest
	dest=$(cache_path "$repo" "$resolved" "$path")
	mkdir -p "$(dirname "$dest")"
	cat_file "$repo" "$resolved" "$path" > "$dest"
	printf '%s\n' "$dest"
}

range_file() {
	require_jq
	local repo="$1"
	local ref="${2:-}"
	local path="$3"
	local start="$4"
	local end="$5"
	[[ -n "$path" ]] || die "path required"
	[[ -n "$start" && -n "$end" ]] || die "start/end required"
	local dest
	dest=$(cache_file "$repo" "$ref" "$path")
	sed -n "${start},${end}p" "$dest"
}

find_file() {
	require_jq
	local repo="$1"
	local pattern="$2"
	[[ -n "$pattern" ]] || die "pattern required"
	local query="filename:$pattern repo:$repo"
	local encoded
	encoded=$(urlencode "$query")
	api_get "https://api.github.com/search/code?q=$encoded" | jq -r '.items[] | .path' | head -n "$MAX_SEARCH"
}

search_code() {
	require_jq
	local repo="$1"
	shift
	local query="$*"
	[[ -n "$query" ]] || die "query required"
	local full_query="$query repo:$repo"
	local encoded
	encoded=$(urlencode "$full_query")
	api_get_textmatch "https://api.github.com/search/code?q=$encoded" | jq -r '.items[] | .path' | head -n "$MAX_SEARCH"
}

cmd="${1:-}"
shift || true

case "$cmd" in
	repo-info)
		[[ $# -ge 1 ]] || die "repo-info requires OWNER/REPO"
		repo_info "$1"
		;;
	ls)
		[[ $# -ge 1 ]] || die "ls requires OWNER/REPO"
		ls_dir "$1" "${2:-}" "${3:-}"
		;;
	cat)
		[[ $# -ge 2 ]] || die "cat requires OWNER/REPO [ref] path"
		if [[ $# -eq 2 ]]; then
			cat_file "$1" "" "$2"
		else
			cat_file "$1" "$2" "$3"
		fi
		;;
	cache)
		[[ $# -ge 2 ]] || die "cache requires OWNER/REPO [ref] path"
		if [[ $# -eq 2 ]]; then
			cache_file "$1" "" "$2"
		else
			cache_file "$1" "$2" "$3"
		fi
		;;
	range)
		[[ $# -ge 4 ]] || die "range requires OWNER/REPO [ref] path start end"
		if [[ $# -eq 4 ]]; then
			range_file "$1" "" "$2" "$3" "$4"
		else
			range_file "$1" "$2" "$3" "$4" "$5"
		fi
		;;
	find-file)
		[[ $# -ge 2 ]] || die "find-file requires OWNER/REPO pattern"
		find_file "$1" "$2"
		;;
	search)
		[[ $# -ge 2 ]] || die "search requires OWNER/REPO query"
		search_code "$1" "${*:2}"
		;;
	-h|--help|help|"" )
		usage
		;;
	*)
		die "unknown command: $cmd"
		;;
esac
